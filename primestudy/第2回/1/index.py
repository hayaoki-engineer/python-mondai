# 3

# 数値に関する次の記述のうち、正しいものはどれか。

# 自分の答え
# 演算を行うための「 + 」や「 - 」などの記号はオペランドと呼ばれ、演算の対象は演算子と呼ばれる。
# 演算の対象はオペランドである。

# 正解
# 整数はintという型を持つ。小数点を伴う数はfloatという型を持つ。除算は常にfloatを返す。
# 除算 5 / 2 = 2.5 ← floatを返す

# 切り下げ除算を行って整数解を得たい場合（剰余を捨てたい場合）は「 / 」を使い、剰余のみ得たい場合は「 // 」を使う。
# 切り下げ除算 5 // 2 = 2 ← 「/」ではない
# 剰余        5 % 2 = 1 ← 「//」ではない

# 正解
# 変数は、定義（値の代入）や宣言がなされないまま使おうとするとエラーとなる。

# 対話モードでは、最後に表示した式を変数「**」（アスタリスク2つ）に代入してある。
# 最後の評価結果は _ という変数に格納されるので、「**」（アスタリスク2つ）に代入は誤り。

# 7

# 次の変数Zenに関して指定した場合、実行時にエラーとならないものはどれか。

# Zen = 'BeautifulIsBetterThanUgly'

# 自分の答え
# Zen[50]
# Zenの文字列は26文字であり、インデックス50は存在しないため、IndexErrorが発生します。

# 正解
# Zen[1000:10000]
# スライスは範囲外のインデックスを指定してもエラーを返さず、空の文字列を返します。

# Zen[10] = 'a'
#文字列は不変（immutable）であり、インデックスを使って直接変更することはできません。TypeErrorが発生します。

# Zen['B']
# 文字列のインデックスには整数を使用する必要があり、文字列をインデックスとして指定するとTypeErrorが発生します。

# Zen[1:10] + b
# bが定義されていない場合、NameErrorが発生します。もしbが定義されている場合は、Zen[1:10]の部分は正常に動作しますが、bの値によって結果が変わります。


# 8

# 次のコードの実行結果として正しいものはどれか。

# a, b = 0, 1
# while a < 10:
#     print(a, end=',')
#     a, b = b, a+b


# 9

# 次のコードの実行結果として正しいものはどれか。

# months = ['January', 'March', 'May', 'July']
# months.append('September')
# => ['January', 'March', 'May', 'July', 'September']

# for month in months[:]:
#     if len(month) > 5:
#         months.insert(0,month)

# print(months, end = '')

# 自分の答え
# ['March', 'January', 'January', 'March', 'May', 'July']

# 正解
# ['September', 'January', 'January', 'March', 'May', 'July', 'September']

# 解説
# 条件チェック: 各月の名前の長さが5より大きいかを確認します。
# 'January'（7文字）と 'September'（9文字）は条件を満たす
# 挿入操作: insert(0, month)を使って、条件を満たす月をリストの先頭に追加します。
# 'January'と'September'がそれぞれ挿入される


# 11

# for i in range(-3, -18, -3):
#     print(i, end=", ")

# 自分の答え
# -6, -9, -12, -15,

# 正解
# -3, -6, -9, -12, -15,


# 14

# 次のコードに関し、【A】の行の出力として正しいものはどれか。

# def culc(a, b, squares=[], cubes=[]):
#     squares.append(a ** 2)
#     cubes.append(b ** 3)
#     return squares, cubes

# print(culc(2,2))
# => ([4], [8])

# print(culc(3,3))
# => ([4, 9], [8, 27])

# print(culc(4,4)) 【A】
# => ([4, 9, 16], [8, 27, 64])

# print(culc(5,5))


# 16

# 次のコード1行目の【A】【B】に入る組み合わせとして正しいものはどれか。

# def shop(name, *argsY, **argsX):
    
#     print("flowershop:", name)

#     keys = sorted(argsX.keys())

#     for kw in keys:
#         print(kw, ":", argsX[kw])
  
#     for Y in argsY:
#         print(Y)

# shop("Iris","Open: 9:30 am","Close: 10:30 pm","Monday and holidays are closed.",bouquet="Sunflower",plants="Pachira",dried="Rose")

# 自分の答え
# *argsX, **argsY

# 正解
# *argsY ,**argsX

# 解説
# *argsY は位置引数を表し、**argsX はキーワード引数を表します。



# 17

# 次の記述のうち、誤っているものはどれか。

# 正解
# 例えば「def func(a: int, b:str) -> value」と関数を記述したときにアノテーションに該当するものは「-> value」のみである。
# => 関数のアノテーションは、引数や戻り値の型を示すために使用される
# => 正しくは、「アノテーションに該当するものは a: int, b: str, -> value のすべてである」

# 関数注釈（アノテーション）は関数の__annotations__属性にディクショナリとして格納され、関数のほかの部分にはいかなる影響も及ぼさない。
# docstringの1行目は、常にオブジェクトの目的の短く簡潔な要約を記述し、大文字で始まりピリオドで終わる行とすべきである。
# docstringに2行目以降がある場合、2行目は空行としてようやくと他の記述を視覚的に分離すべきである。
# PEP 8では、演算子の周囲やカンマの後ろにはスペースを入れるが、カッコのすぐ内側にはスペースを入れるべきではないとされる。

# 22

# 次のコードの実行結果として正しいものはどれか。

# Zen = 'FlatIsBetterThanNested'
# print(Zen[0:20:3])

# 自分の答え
# FtBtTnsd
# 正解
# FtBtTns

# 24

# 対話モードで入力したときに「True」が返されるものは次のうちどれか。

# (-1, -10, -3, -4) > (-1, -2, -5)
# 1 > -1 == (1-2)
# (1, 2) > (1, 2, -1)
# 'Matplotlib' > 'NumPy' > 'pandas' > 'scikit-learn'
# ('bb', 'c') > ('bcd', 'a')

# 正解
# 1 > -1 == (1-2)

# 解説
# 最初に 1 > -1 を評価します。これは True
# 次に (1-2) を計算します。これは -1
# その後、-1 == -1 を評価します。これも True
# 1 > -1 が True で、-1 == -1 も True
# Pythonでは、True と True の両方が成立している場合、全体の式 1 > -1 == (1-2) も True

# 25

# モジュールに関する次の記述のうち、誤っているものはどれか。

# 正解
# sys.pathが初期化されている場所は、入力スクリプトのあるディレクトリ、PYTHONPATHであり、インストールごとのデフォルトは含まれない。

# パッケージとは、「ドット区切モジュール名」を使って、Pythonのモジュールを構築する方法である。
# あるモジュールがインポートされるときにインタープリタが検索する順序は、まずビルトインモジュール、次にsys.path変数で得られるディレクトリである。シンボリックリンクを置いてあるディレクトリはモジュール検索パスに入らない。
# Pythonはソースファイルの最終更新日時をコンパイル済みのバージョンと比較し、再コンパイルが必要か判断する。これは完全に自動的に行われる。
# コンパイル済みのモジュールはプラットフォーム非依存なので、ひとつのライブラリを異なるアーキテクチャのシステム間で共有できる。


# 29

# エラーと例外に関する次の記述のうち誤っているものはどれか。

# 正解 = 誤り
# [Ctrl]+[C]キーなどでユーザーがプログラムに割り込みをかけると、KeyError例外が送出される。

# raise文を用いることで、指定の例外を意図的に発生させることができる。raiseの引数は送出する例外を示すものであり、例外インスタンスでも、Exceptionクラスの派生クラスであるクラス（例外クラス）でも構わない。

num = -1
if num < 0:
    raise ValueError("負の数は許可されていません。")

# raiseの引数：発生させる例外の種類とその詳細を示すメッセージ

# 発生した例外に値が付随することもあり、これを例外の引数と呼ぶ。except 節では、例外名の後に変数を指定することができる。この変数は例外インスタンスに結び付けられており、instance.args に例外インスタンス生成時の引数が格納される。

try:
    num = -1  # 負の数を設定
    if num < 0:
        raise ValueError("負の数は許可されていません。")  # 例外を発生させる
except ValueError as e:  # ValueErrorをキャッチして、変数eを指定
    # 例外が発生した場合の処理
    print("エラーが発生しました。")  # エラーメッセージを表示
    print(f"エラーの内容: {e}")  # 例外のメッセージを表示
    print(f"エラーの詳細情報: {e.args}")  # 例外の引数を表示

# パーサ（構文解釈器）は違反のある行を表示し、最初にエラーが検知された点を小さな矢印で示す。エラーは矢印より前のトークンが原因である。

# 例外のほとんどはプログラムでは処理されず、その結果はエラーメッセージにあらわれる。エラーメッセージの最終行には、NameError、TypeErrorなど例外の型が記されている。


# 31
# 32
# 33
# 35
# 36
# 37
# 39